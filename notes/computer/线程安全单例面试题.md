# 1、饿汉式

![饿汉式](imgs/%E9%A5%BF%E6%B1%89%E5%BC%8F.png)

- **问题1**

防止该类的子类不适当的覆盖了父类中的方法，破坏它的单例。

- **问题2**

如果这个类实现了序列化，那么这个进行反序列化的时候也会生成新的对象，这和单例模式生成的对象是不同的对象，相当于就破坏了单例。

解决方法（添加代码）：

```java
public Object readResolve{
	return INSTANCE；
}
```

此时，进行反序列化的过程中调用readResolve方法，将返回我们的INSTANCE对象

- **问题3**

1. 不将访问权限设置为私有的话，其他类都可调用该类生成新的实例，显然不符合单例模式的设计原则。
2. 不能。反射能够获得该类的构造器对象，并通过setAccessable方法破坏该构造的权限，从而创建新的实例。

- **问题4**

能。静态成员变量是在类加载阶段完成的。类加载阶段由JVM保证这些代码的安全性。

- **问题5**

使用方法的话可以提供更好的封装性，可以对创建的这个单例对象有更多的控制，还可以提供一些泛型的支持。

# 2、懒汉式

## 1）锁方法

![懒汉式1](imgs/%E6%87%92%E6%B1%89%E5%BC%8F1.png)

该方式是可以保证线程安全问题的。但是效率较低，我们只要在第一次创建单实例对象的时候才需要加锁，而使用这种实现方式在后续调用时仍然需要加锁，导致性能较低。

> **为什么这里不能锁住INSTANCE变量？**
>
> 首先INSTANCE是NULL，它需要重新赋一次值，而且它还是空对象，空对象不能加锁的（synchronize需要找到一个对象，并根据这个对象去分配monitor锁）。

## 2）双重检测法

![饿汉式2](imgs/%E9%A5%BF%E6%B1%89%E5%BC%8F2.png)

- **问题1**

synchronize 中 INSTANCE = new Singleton() 代码可能发生指令重排。防止线程并发时，某个线程拿到了INSTANCE的引用还没有调用构造方法，即不完整的对象。

- **问题2**

当已经创建出单实例对象时，就不需要进行加锁了，性能更高。

- **问题3**

防止首次创建INSTANCE对象的时候，多个线程并发的问题。

## 3）静态内部类法

![饿汉式3](imgs/%E9%A5%BF%E6%B1%89%E5%BC%8F3.png)

- **问题1**

属于懒汉式。因为类加载是懒惰的，类总是是在第一次被用到才会触发它的类加载操作，如果你只是用外面的Singleton，没有使用到getInstance方法，内部类LazyHolder是不会被加载的，那么其中的静态变量也不会进行初始化操作

- **问题2**

否，当第一次调用getInstance()方法时，就会触发LazyHolder的类加载，给这个INSTANCE作初始化，由JVM来保证静态变量的线程安全性。

## 4）枚举类

![枚举](imgs/%E6%9E%9A%E4%B8%BE.png)

- **问题1**

通过观察反编译后的代码，可以发现枚举类中的INSTANCE其实就是 final static 修饰的成员变量而已，所以它是单实例的。

- **问题2**

没有。它是在类加载阶段完成的，类加载阶段由JVM保证这些代码的安全性。因此不会有安全问题。

- **问题3**

不能。反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。

- **问题4**

枚举类会实现Enum类，而Enum类会实现Serializable，所以枚举类默认都是可以进行序列化和反序列化的。但是，枚举类在实现过程中考虑到了反序列化会破坏单例的问题，可以避免反序列化时出现问题，无需我们做额外的操作。

- **问题5**

饿汉式。

- **问题6**

我们只需要给该枚举类加一些构造方法即可。

